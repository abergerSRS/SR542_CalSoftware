# -*- coding: utf-8 -*-
"""
Created on Wed Feb  5 14:20:07 2020

@author: aberger

This program imports four columns of data:
    1. enc raw count (0-399)
    2. input capture of shaft edges on "free running" 60 MHz FTM counter
    3. running total of number of encoder edges captured
    4. delta FTM count between most recent two edges, rescaled by tick spacing
    
And is used to validate the shaft encoder calibration performed by encoderInputCapture.py

The data are generated by a SPDN command, at which point current to the motor is
disabled, and the motor is allowed to spin-down freely. At 14648 kHz, the following
data points are sampled:
    motor.rotorAngle;
    shaftInputCap;
    numCapEdges;
    totalCounts;
Note that at 915 Hz, numCapEdges and totalCounts are reset by MeasureShaftSpeed()
"""

import numpy as np
import matplotlib.pyplot as plt
import os

plt.close('all')

file_dir = os.path.abspath(r"C:\Users\aberger\Documents\Projects\SR542\Firmware\SR544\tools")
#filename = 'edgesAndCounts_80Hz_10100Blade_UVWconnected.txt'
#filename = 'edgesAndCounts_80Hz_10100Blade_UVWdisconnected.txt'
#filename = 'edgesAndCounts_80Hz_10100Blade_ticksRescaled.txt'
filename = 'edgesAndCounts_35Hz_10-100blade_CW_400CountCalVerify.txt'

full_path = os.path.join(file_dir, filename)

data = np.loadtxt(full_path, delimiter=',', usecols=[0,1,2,3], skiprows=0)

encCount = data[:,0]
shaftInputCap = data[:,1] #last input captured edge on a free-running FTM counter
numEncEdges = data[:,2] #number of captured encoder edges since last speed measurement
totalCounts = data[:,3] #number of FTM counts, rescaled by tickRescale, since last speed measurement

N_samples = len(encCount)
N_enc = 400 #number of ticks on shaft encoder
f_FTM = 60e6 #Hz
FTM_MOD = 4096 #FTM_MOD for the FTM peripheral used to collect these data

dt = FTM_MOD/f_FTM
t = np.linspace(0, dt*N_samples, N_samples)
encoderCount = np.linspace(0, N_enc - 1, N_enc)

# Given: 
#1. encCount - raw encoder count
#2. edges -  FTM input captured CnV values @ edges
#3. time - linspace-generated time array
#4. maxCount - maximum encoder count (usually 100 or 400)
# Look for changes in the input captured FTM value and use that to generate deltas.
# Return: 
#1. rawCount[i] = shaft encoder count at captured edge: counts[i]
#2. deltaCount[i] = change in shaft encoder count: counts[i] - counts[i-1]
#3. deltaFTM[i] = change in input capture value: CnV_i - CnV_(i-1)
#4. t1[i] = time at edge corresponding to CnV_i
def measureCountDeltas(counts, edges, time, maxCount):
    rawCount = np.zeros(0)
    deltaCount = np.zeros(0)
    deltaFTM = np.zeros(0)
    t1 = np.zeros(0)
    for i, edge in enumerate(edges[1:], start=1):
        if edge != edges[i-1]:
            rawCount = np.append(rawCount, counts[i])
            deltaCount = np.append(deltaCount, (counts[i] - counts[i-1])%maxCount)
            t1 = np.append(t1, time[i])
            deltaFTM = np.append(deltaFTM, edge - edges[i-1])
            
    return rawCount, deltaCount, deltaFTM, t1

def extractCountDeltas(FTMcount, time):
    delta = np.zeros(0)
    t1 = np.zeros(0)
    for i, count in enumerate(FTMcount[1:], start=1):
        if (count != 0) and (count != FTMcount[i-1]):                
            t1 = np.append(t1, time[i])
            if(count < FTMcount[i-1]):
                delta = np.append(delta, count)
            else:
                delta = np.append(delta, count - FTMcount[i-1])
            
    return delta, t1

# Given: a 1-D array of data
# Returns: a sliding window average where the window for the i-th average
# is centered on the i-th point (so equally forward- and backward-looking)
def movingAverage(data, windowSize):
    avg = np.zeros(len(data))
    delta = int(np.floor(windowSize/2))
    
    for i in range(delta):
        avg[i] = data[i]
        
    for i in range(len(data) - delta, len(data)):
        avg[i] = data[i]
        
    for i, datum in enumerate(data[delta:-delta], start=delta):
        avg[i] = np.sum(data[i - delta: i + delta + 1])/(windowSize+1)
    
    return avg

# First, calculate the delta FTM counts
rawCountAtDelta, rawCountDelta, rawFtmDelta, timeAtRawDelta = measureCountDeltas(encCount, shaftInputCap, t, N_enc)
rescaledFtmDelta, timeAtRescaledDelta = extractCountDeltas(totalCounts, t)

# This can be easily converted to delta t in seconds
rawFtmDeltaT_sec = rawFtmDelta/f_FTM
rescaledDeltaT_sec = rescaledFtmDelta/f_FTM

# Which can be converted to estimated speed as a function of time:
encSpeed = rawCountDelta/(N_enc*rawFtmDeltaT_sec)
rescaledSpeed = 1/(N_enc*rescaledDeltaT_sec)
        
# Calculate the moving average to smooth over the fine-scale variation due to 
# encoder errors (window size >= N_enc)
windowSize = int(5*N_enc/2)
avgEncSpeed = movingAverage(encSpeed, windowSize)

# Plot Speed vs Time
fig1, ax1 = plt.subplots()
ax1.plot(timeAtRawDelta[1:], encSpeed[1:], label='raw encoder speed')
ax1.plot(timeAtRawDelta[1:], avgEncSpeed[1:], label=f'windowed average, N={windowSize}')
ax1.plot(timeAtRescaledDelta[1:], rescaledSpeed[1:], label='rescaled in firmware')
ax1.set_ylim(min(encSpeed[1:]), max(encSpeed[1:]))
ax1.set_xlabel('time (s)')
ax1.set_ylabel('speed (rev/s)')
ax1.set_title('Free Spindle Decay: speed vs. time')
ax1.legend()

# Plot speed "error" vs time
fig2, ax2 = plt.subplots()
ax2.plot(timeAtRawDelta[1:], avgEncSpeed[1:] - encSpeed[1:], label='raw encoder speed')
ax2.plot(timeAtRescaledDelta[1:], avgEncSpeed[1:] - rescaledSpeed[1:], label='rescaled in firmware')
ax2.set_xlabel('time (s)')
ax2.set_ylabel('speed error (rev/s)')
ax2.set_title('Speed error (relative to windowed average)')
ax2.legend()
